
// Old stuff down here -----------------


int igd_search_combined_version(int argc, char **argv)
{   //igd[0] search[1] home/john/IGD/rme_igd/roadmap.igd[2] -q[3] query100.bed[4]
    if(argc<4)
        return search_help(EX_OK);     
    
    char *igdName = argv[2]; 
    char *ftype = igdName + strlen(igdName) - 4;
    if(strcmp(".igd", ftype)!=0){
        printf("%s is not an igd database", igdName);
        return EX_OK;
    }    
    FILE* fi = fopen(igdName, "rb");
    if(!fi){
        printf("%s does not exist", igdName);
        return EX_OK;
    }
    fclose(fi); 
        
    int32_t v = 0, qs=1, qe=2;
    int i, i1, j, checking=0, mode=-1, mt=0, ext=0, xlen=0,  mv=0, mx=0, ichr, k;
    char out[64]="";  
    char *chrm;    
    char *qfName = "";  
    uint64_t ols;
    
    //----------------------------------------------------- 
    char tmp[128];  
    IGD = get_igdinfo(igdName);     
    strcpy(tmp, igdName);
    tmp[strrchr(tmp, '.')-tmp] = '\0';
    strcpy(IGD->fname, tmp);
    char *idFile = tmp; //str_split(tmp, '.', &nCols)[0];
    strcat(idFile, "_index.tsv");            
    IGD->finfo = get_fileinfo(idFile, &IGD->nFiles);      
    int32_t nfiles = IGD->nFiles; 
    int64_t *hits = calloc(nfiles, sizeof(int64_t));
    //-----------------------------------------------------
    //for(i=0;i<nfiles;i++){
    //  printf("%i\t%i\t%i\n", i, IGD->finfo[i].nr, IGD->finfo[i].md);
    //}

    // NS: CLI argument parsing:
    for(i=3; i<argc; i++){
        if(strcmp(argv[i], "-q")==0){
            if(i+1<argc){
                qfName = argv[i+1];
                mode = 1;
            }
            else{
                printf("No query file.\n");
                return EX_OK;
            }   
        }
        else if(strcmp(argv[i], "-r")==0){
            if(i+3<argc){
                mode = 2;
                chrm = argv[i+1];
                qs = atoi(argv[i+2]);
                qe = atoi(argv[i+3]);
            }        
        }
        else if(strcmp(argv[i], "-v")==0){//>=v
            mv = 1;
            if(i+1<argc)
                v = atoi(argv[i+1]);
        }
        else if(strcmp(argv[i], "-m")==0){
            mode = 0;
        } 
        else if(strcmp(argv[i], "-s")==0){
            mode = 3;   //seqpare
        }                  
        else if(strcmp(argv[i], "-o")==0){
            if(i+1<argc)
                strcpy(out, argv[i+1]);
        }   
        else if(strcmp(argv[i], "-c")==0){
            checking = 1;
        }                              
    }  
     
    //----------------------------------------------------------
    fP = fopen(igdName, "rb");              //share
    if(mode==0){
        uint32_t **hitmap = malloc(nfiles*sizeof(uint32_t*));
        for(i=0;i<nfiles;i++)
            hitmap[i] = calloc(nfiles, sizeof(uint32_t));
        if(v>0)
            getMap_v(hitmap, v);
        else
            getMap(hitmap);                 
        FILE *fp;
        if(strlen(out)<2)strcpy(out,"Hitmap");
        fp = fopen(out, "w");
        if(fp==NULL)
            printf("Can't open file %s\n", out);
        else{
            fprintf(fp, "%u\t%u\t%u\n", nfiles, nfiles, v);
            for(i=0;i<nfiles;i++){
                for(j=0;j<nfiles;j++)
                    fprintf(fp, "%u\t", hitmap[i][j]); 
                fprintf(fp, "\n");
            } 
            fclose(fp);
        }     
    
        for(i=0;i<nfiles;i++)
            free(hitmap[i]);
        free(hitmap);   
    }
    else if(mode==1){//for a query dataset (file)  
        if(IGD->gType==0)
            getOverlaps0(qfName, hits);
        else{
            if(v>0)
                getOverlaps_v(qfName, hits, v);
            else
                getOverlaps(qfName, hits);
        }
        printf("index\t File_name\t number of regions\t number of hits\n"); 
        int64_t total = 0;       
        for(i=0;i<nfiles;i++){
            if(hits[i]>0)
                printf("%i\t%i\t%lld\t%s\n", i, IGD->finfo[i].nr, (long long)hits[i], IGD->finfo[i].fileName); 
            total += hits[i];
        }
        printf("Total: %lld\n", (long long)total);
    }
    else if(mode==2){//mode 2 for a single region
        if(IGD->gType==0)
            ols = get_overlaps0(chrm, qs, qe, hits); 
        else{
            if(v>0)
                ols = get_overlaps_v(chrm, qs, qe, v, hits);
            else
                ols = get_overlaps(chrm, qs, qe, hits);             
        }
        printf("index\t File_name\t number of regions\t number of hits\n");        
        for(i=0;i<nfiles;i++)
            printf("%i\t%i\t%lld\t%s\n", i, IGD->finfo[i].nr, (long long)hits[i], IGD->finfo[i].fileName);
    }
    else if(mode==3){//output seqpare index
        double *sm = malloc(nfiles*sizeof(double));
        seqOverlaps(qfName, sm);
        printf("index\t File_name\t number of regions\t similarity\t dataset name\n");       
        for(i=0;i<nfiles;i++){
            printf("%i\t%i\t%10.6f\t%s\n", i, IGD->finfo[i].nr, sm[i], IGD->finfo[i].fileName); 
        }  
        free(sm);
    }
    else
        return search_help(EX_OK);      

    fclose(fP);
    free(IGD->nTile);
    for(i=0;i<IGD->nCtg;i++){
        free(IGD->nCnt[i]);
        free(IGD->tIdx[i]);
    }
    free(IGD->nCnt);
    free(IGD->tIdx);
    free(IGD->cName);
    free(IGD->finfo);
    free(IGD);
    free(hits);
    return EX_OK;
}


//-------------------------------------------------------------------------------------
int igd_create_combined_version(int argc, char **argv)
{
    if (argc < 5) 
        return create_help(EX_OK);       

    int32_t i, j, n;
    char ipath[1024];
    char opath[1024];
    char *s1, *s2;
    strcpy(ipath, argv[2]);
    strcpy(opath, argv[3]);
    char *dbname = argv[4]; 
    int dtype = 1, ftype = 0;   //file type 1: list of bed file
    
    tile_size = 16384;                              //2^14 = 16384; arg -b 14 (default)

    // process command-line arguments
    for(i=5; i<argc; i++){
        if(strcmp(argv[i], "-s")==0 && i+1<argc)    //data structure type
            dtype = atoi(argv[i+1]); 
        if(strcmp(argv[i], "-b")==0 && i+1<argc){
            n = atoi(argv[i+1]);
            if(n>10 && n<20)
                tile_size = pow(2, n);  
        } 
        if(strcmp(argv[i], "-f")==0) 
            ftype = 1;                                
    }
    
    if(opath[strlen(opath)-1]!='/'){
        strcat(opath, "/");
    }          
          
    if(ftype==0 && dtype!=2){                            
        if(ipath[strlen(ipath)-1]=='/'){
            strcat(ipath, "*");
        }
        else if(ipath[strlen(ipath)-1]!='*'){
            strcat(ipath, "/*");
        }
    }  
    
    //check if the subfolders exist:    
    char ftmp[1024];      
    struct stat st = {0};  
    
    sprintf(ftmp, "%s%s%s", opath, dbname, ".igd");
    if(stat(ftmp, &st) == 0)
        printf("The igd database file %s exists!\n", ftmp);  
    else{
        if (stat(opath, &st) == -1){
            mkdir(opath, 0777);    
        }
        sprintf(ftmp, "%s%s", opath, "data0");
        if (stat(ftmp, &st) == -1)
            mkdir(ftmp, 0777);
        if(dtype==0)
            create_igd0(ipath, opath, dbname);
        else if(dtype==2)
            create_igd_bed4(ipath, opath, dbname);
        else if(ftype==1)
            create_igd_f(ipath, opath, dbname);
        else //default
            create_igd(ipath, opath, dbname);         
    } 

    return EX_OK;
}

